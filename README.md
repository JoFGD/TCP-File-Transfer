# TCP-File-Transfer

  The application protocol designed is a TCP based file transfer system which enables the client to receive files from the server using a ‘get’ command, send files to the server using a ‘put’ command, and list the files currently stored on the server using a ‘list’ command. An external module is also used and shared between the client and server.
  
  The server first creates a socket so that new connections can be received, the socket is then registered with the OS kernel so that messages sent to the user-defined port number are delivered to the ‘server’ program. A queue is subsequently created so that new connection requests can be added by the OS kernel. These actions are encapsulated in a try-except clause to catch connection-based errors. A while loop is then used to loop continuously searching for a connection with a client, unless a fatal error occurs. Any errors inside the while loop are handled by a try-except clause. When a client is found a connection request from the earlier queue is dequeued and the socket and client IP/port number enabling client communication are then returned for use throughout the program. If no client is found the program blocks until a client is found.
  
  Upon creation, the client also creates a socket with which a connection can be made to the server. The variables used in the program are then initialised as appropriate, including the creation of a server address tuple comprising of an IP and port number specified by the initial client input. Following this, the client attempts to connect the created socket to the server. As it is encapsulated in a try-except clause any connection-based errors will be caught. Upon a successful connection procedure, a TCP connection will be established, allowing for data transfer. Any errors in the program are caught as an exception and a detailed error message including port number, IP, action code, file name and the error itself will be printed.
  
  Following a successful connection, the client then proceeds to determine the action desired by the user. The entirety of this code is in a try-except clause to ensure errors caused by the socket connection or else by user input are caught. The program first guarantees the required format of the user input is strictly adhered to, otherwise an error is raised – with a message also being sent to the server to keep it informed about the success/failure of the client at this point. If “success” is sent by the client, the server also moves on. The client is blocked from continuing until a message is returned by the server to ensure synchronicity. Ensuing this, the client sends a formatted string to the server containing the action code and file name which are separated via splitting according to a predefined separation string. The client also checks the action code format is correct, sending an additional message to the server if not so that both can raise and display an appropriate error message.
  
  The first action defined is ‘put’. After the aforementioned steps, the server checks whether the file intended to be sent already exists in the ‘server’ directory. The server then sends a message to the client. The client similarly checks if the file exists in the ‘client’ directory and sends a message back to inform the server. The client then calls a ‘send_file’ function from a module, and the server calls a ‘recv_file’ from the same module.
  
  The second action defined is ‘get’. In this case, the server checks if the file requested exists in the ‘server’ directory and sends a message to the client with a ‘success’/error message string. The client checks the file does not already exist in the ‘client’ directory and sends a similarly formatted message to the server. The client then calls the ’recv_file’ function from the external module, and the server calls the ‘send_file’ function.
  
  The final action defined is ‘list’. The server calls a ‘send_listing’ function from the module, and the client calls a ‘recv_listing’ function which returns a list of the names of files on the ‘server’ directory. A for loop is then used to print each element and display the names on the client.
  There are four functions in the external module. The first of which is ‘send_file’. It takes the socket, file name and recv_check as arguments. The recv_check argument comes from the earlier server/client checks based on the validity of the file being sent/received. If the message received was an error message, this is raised – otherwise if it was ‘success’ the function carries on as normal. The file being sent is opened in read-binary mode. A while loop runs and reads the data in the file and sends it to the server/client until no data is left to send.
  
  The second function in the module is ‘recv_file’. It takes the same arguments as ‘send_file’ and performs the same checks using ‘recv_check’. The file is opened/created in write-binary mode. A while loop runs until all data from the client/server has been received/written into the new file.
  The third function in the module is ‘send_listing’. It only takes the socket as an argument. It contains a for loop which runs through the ‘server’ directory, sending the file names to the client, each separated by a predefined separator string.
  
  The final function in the module is ‘recv_listing’. It also only takes the socket as an argument. It uses a while loop to run until all file names have been received from the server. Packets of data (names) received is decoded and added to a string which is split according to the predefined separator and returned to the client as a list of strings.
